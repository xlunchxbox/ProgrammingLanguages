import scala.io.Source._
import scala.xml._
import scala.actors.Futures._
import scala.collection.immutable._

def readFile(filename: String): String = scala.io.Source.fromFile(filename).mkString

def fetchXML(code: String): Elem = XML.load("http://weather.yahooapis.com/forecastrss?w="+code+"&u=f")

def parseXML(xml: Elem): Map[String, List[String]] = 
	Map((xml \\ "@region").text + " \t " + (xml \\ "@city").text -> 
		List((xml \\ "@temp").text, ((xml \\ "@text").head).text, ((xml \\ "@high").head).text, ((xml \\ "@low").head).text))

def getResultsSingleThread(cities: List[String]) = for(i <- 0 to cities.length - 1) yield parseXML(fetchXML(cities(i)))

def getResultsMultithread(cities: List[String]) = {
	val tasks = for (i <- 0 to cities.length - 1) yield future {
		parseXML(fetchXML(cities(i)))
	} 
	awaitAll(5000L, tasks: _*)
}

def singleThread(cities: List[String]) = getResultsSingleThread(cities).reduceLeft(_++_)

def multiThread(cities: List[String]) = (getResultsMultithread(cities) flatten).asInstanceOf[List[Map[String, List[String]]]].reduceLeft(_++_)

def getMax(weathers: Map[String, List[String]]) = weathers.maxBy(_._2(0).toInt)

def getMin(weathers: Map[String, List[String]]) = weathers.minBy(_._2(0).toInt)

def output(weathers: Map[String, List[String]], max: (String, List[String]), min: (String, List[String])) = {
	println("State \t City \t\t High \t Low \t Current Condition")
	weathers.foreach{ case (k,v) => println(k + " \t " + v(2) + " \t " + v(3) + " \t " + v(0) + " \t " + v(1)) }
	println("The city with the highest temperature:")
	println(max._1 + " \t " + max._2(2) + " \t " + max._2(3) + " \t " + max._2(0) + " \t " + max._2(1))
	println("The city with the lowest temperature:")
	println(min._1 + " \t " + min._2(2) + " \t " + min._2(3) + " \t " + min._2(0) + " \t " + min._2(1))
}

def timeIt(function:  List[String] => Map[String, List[String]], cities:  List[String]) = {
	val startTime = System.nanoTime
	val result = function(cities)
	val max = getMax(result)
	val min = getMin(result)
	val sortMap = TreeMap(result.toSeq:_*)
	val endTime = System.nanoTime
	val executionTime = (endTime - startTime)/1e9
	println("Total time is " + executionTime + "s")
	output(sortMap, max, min)
}

val cities = readFile("cities.txt").split(",").toList
println("\nSingle Thread")
timeIt(singleThread, cities)
println("\nMultithread")
timeIt(multiThread, cities)