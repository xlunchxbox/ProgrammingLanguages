def time(f: => Unit)={
	val s = System.currentTimeMillis
	f
	System.currentTimeMillis - s
}
//#1 Iterative Iterative
def fib_iterative_iterative(n: Int) = {
	var x = 0
	var y = 1
	
	def next(x: Int , y: Int) = Pair(y, x + y);
	var i =0
	while(i < n){
		val Pair(a, b) = next(x, y);
		x = a
		y = b
		
		i = i + 1
	}
	x
}

val n = 40
println("Time Elapsed:" + time{println("Fib ("+ n + "):" + fib_iterative_iterative(n))} + "ms")


//#2 Recursive Recursive
def fib_recursive_recursive( n: Int): Int = n match {

    case 0 | 1 => n
    case _ => fib_recursive_recursive( n -1) + fib_recursive_recursive( n-2)
  }

val m = 40
println("Time Elapsed:" + time{println("Fib ("+ m + "):" + fib_recursive_recursive(m))} + "ms")


val position = 1000000

// Problem 3 - Fib w/Tail Recursion
def tail_fib(oldVal: Int, newVal: Int, pos: Int): Int = {
	pos match {
	case 1 => newVal
	case _ => tail_fib(newVal, oldVal + newVal, pos - 1)
	}
}

def call_tail_fib(pos: Int) = tail_fib(0, 1, pos)

println("Time Elapsed:" + time{println("Tail Fib At position " + position + ": " + call_tail_fib(position))
}+"ms")

// Problem 4 - Fib w/Lazy eval through Stream
def lazy_fib(oldVal: Int, newVal: Int): Stream[Int] =
	oldVal #:: lazy_fib(newVal, oldVal + newVal)

def call_lazy_fib(pos: Int) = lazy_fib(1, 1).take(pos).last

println("Time Elapsed:" + time{println("Lazy Fib At position " + position + ": " + call_lazy_fib(position))
}+"ms")