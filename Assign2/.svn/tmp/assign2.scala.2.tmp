import BigInt._

def time(position: Int)(function: Int => BigInt) ={
	val timeBefore = System.currentTimeMillis
	print("Position: "+position+" Value: "+function(position)+" Time: "+
	(System.currentTimeMillis - timeBefore)+"ms\n")
}

//#1
def fibIterativeIterative(position: Int) = {
	var x = BigInt(0)
	var y = BigInt(1)
	
	def next(x: BigInt , y: BigInt) = Pair(y, x + y);
	var i = 0
	for(i <- 1 to position){
		val Pair(a, b) = next(x, y);
		x = a
		y = b
	}
	x
}

//#2
def fibRecursiveRecursive( position: Int): Int = position match {
    case 0 | 1 => position
    case _ => fibRecursiveRecursive(position -1) + fibRecursiveRecursive(position-2)
  }

// Problem 3 - Fib w/Tail Recursion
def callTailFib(pos: Int): BigInt = {
	def tailFib(oldVal: BigInt, newVal: BigInt, pos: Int): BigInt = {
		pos match {
		case 1 => newVal
		case _ => tailFib(newVal, oldVal + newVal, pos - 1)
		}
	}
	tailFib(BigInt(0), BigInt(1), pos)
}


// Problem 4 - Fib w/Lazy eval through Stream
def lazy_fib(oldVal: Int, newVal: Int): Stream[Int] =
	oldVal #:: lazy_fib(newVal, oldVal + newVal)

def call_lazy_fib(pos: Int) = lazy_fib(1, 1).take(pos).last





val position = 20
time(position)(fibIterativeIterative)
time(position)(fibRecursiveRecursive)

//change the way you call it
//time(position)(call_tail_fib)
//time(position)(call_lazy_fib)





